#include <lib.h>
#include <daemons.h>
#include <save.h>

inherit LIB_DAEMON;
mapping EventsMap = ([]);
mixed *event_funs = ({});
int connect_warn;
string shiz = "\n---------------\n"+ 
             "%^RED%^CRITICAL%^RESET%^: There was a problem with "+
             "/secure/lib/connect.c . When the upgrade is complete "+
             "you must log out and log back in to make sure the "+
             "correct file is in place.\n---------------\n";

int check_function(string str){
    if(member_array(str,MASTER_D->GetEfuns()) != -1) return 1;
    return 0;
}

int make_empties(){
    string *removes = ({
      "/spells",
      "/psionics",
      "/trades",
      "/prayers",
      "/feats",
    });

    string *empties = ({
      "/cmds/hm",
      "/cmds/builders",
      "/secure/cmds/common",
      "/secure/save/postal",
      "/secure/save/binaries",
      "/secure/save/decre",
      "/secure/save/players",
      "/secure/save/letters",
      "/secure/save/backup",
      "/secure/save/creators",
      "/secure/save/suicide",
      "/secure/save/rid",
      "/secure/save/votes",
      "/secure/upgrades/txt",
      "/www/doc",
      "/www/logs",
      "/doc/lpc/advanced",
      "/doc/tmp",
      "/doc/help/avatars",
      "/doc/help/hm",
      "/doc/help/religion",
      "/doc/help/law",
      "/doc/faq",
      "/log/author_stats",
      "/realms/template/tmp",
      "/realms/template/log",
      "/realms/template/area/etc",
      "/realms/template/area/meals",
      "/realms/template/area/doors",
      "/domains/town/save",
      "/domains/town/virtual/forest",
      "/domains/town/virtual/sub",
      "/domains/town/virtual/surface",
      "/domains/default/save",
      "/domains/default/virtual/sky",
      "/domains/default/virtual/arena",
      "/domains/Ylsrim/save",
      "/domains/Ylsrim/virtual/desert",
      "/verbs/spells",
      "/verbs/undead",
      "/secure/log/intermud",
      "/secure/log/network",
      "/domains/default/save",
      "/domains/town/save",
      "/open",
      "/powers",
      "/powers/spells",
      "/powers/prayers",
      "/powers/feats",
      "/powers/psionics",
      "/powers/trades",
      "/secure/log",
      "/secure/log/adm",
      "/secure/log/bak",
      "/secure/log/intermud",
      "/secure/log/network",
    });

    foreach(string dir in empties){
        catch( mkdir(dir) );
    }
    foreach(string dir in removes){
        catch( rmdir(dir) );
    }
    return 1;
}

void deletes(){
    rm("/domains/campus/room/store2.c");
    rm("/domains/town/room/room.c");
    rm("/domains/default/obj/flow.c");
    rm("/secure/cmds/admins/coordset.c");
}

varargs static void eventUpdate(object whom){
    object remote;
    string a,b;
    string cpw,spw;
    string *file_arr;
    string x = read_file("/secure/daemon/imc2.c");
    int y = sscanf(x,"%s#define IMC2_CLIENT_PW \"%s\"%s",a,cpw,b);
    string config_file = read_file("/secure/include/config.h");
    string newfile = read_file("/secure/daemon/update.blank");
    y = sscanf(x,"%s#define IMC2_SERVER_PW \"%s\"%s",a,spw,b);
    write_file("/secure/daemon/update.c",newfile,1);

    if(!cp("/secure/lib/connect.real","/secure/lib/connect.c")){
       connect_warn = 1;
       if(whom){ 
           tell_player(whom, shiz);
        }
    }

    if(sizeof(config_file)){

        if(!grepp(config_file, "CLASS_SELECTION"))
            config_file = append_line(config_file,"#define HUMANS_ONLY",
              "#define CLASS_SELECTION          0");

        if(!grepp(config_file, "SEVERABLE_LIMBS"))
            config_file = append_line(config_file,"#define HUMANS_ONLY",
              "#define SEVERABLE_LIMBS          1");

        if(!grepp(config_file, "MAX_CALL_OUTS"))
            config_file = append_line(config_file,"#define F_TERMINAL_COLOR",
              "#define MAX_CALL_OUTS            500");

        if(!grepp(config_file, "REQUIRE_QUESTING"))
            config_file = append_line(config_file,"#define MAX_CALL_OUTS",
              "#define REQUIRE_QUESTING         1");

        if(!grepp(config_file, "AUTO_ADVANCE"))
            config_file = append_line(config_file,"#define REQUIRE_QUESTING",
              "#define AUTO_ADVANCE             0");

        config_file = replace_string(config_file,"WEB_SOURCE   ",
          "WEB_SOURCE_IP");
        config_file = replace_string(config_file,"149.152.218.102",
          "204.209.44.12");

        if(!grepp(config_file, "WEB_SOURCE_NAME"))
            config_file = append_line(config_file,"#define WEB_SOURCE_IP",
              "#define WEB_SOURCE_NAME          \"lpmuds.net\"");

        if(!grepp(config_file, "MAX_INVENTORY_SIZE"))
            config_file = append_line(config_file,"#define AUTO_ADVANCE",
              "#define MAX_INVENTORY_SIZE       2048");

        if(!grepp(config_file, "MAX_ATTACKS_PER_HB"))
            config_file = append_line(config_file,"#define MAX_INVENTORY_SIZE",
              "#define MAX_ATTACKS_PER_HB       40");

        if(!grepp(config_file, "MEMUSE_SOFT_LIMIT"))
            config_file = append_line(config_file,"#define MAX_ATTACKS_PER_HB",
              "#define MEMUSE_SOFT_LIMIT        0");

        if(!grepp(config_file, "MEMUSE_HARD_LIMIT"))
            config_file = append_line(config_file,"#define MEMUSE_SOFT_LIMIT",
              "#define MEMUSE_HARD_LIMIT        0");

        if(!grepp(config_file, "MAX_USERS"))
            config_file = append_line(config_file,"#define MEMUSE_HARD_LIMIT",
              "#define MAX_USERS                0");

        write_file("/secure/include/config.h", config_file+"\n", 1);
    }

    call_out( (: make_empties :),0);
    call_out( (: deletes :),0);

    reload(EVENTS_D,0,1);
    EventsMap = EVENTS_D->GetEvents();
    foreach(mixed key, mixed val in EventsMap){
        event_funs += ({ val["function"] });
    }
    if(member_array("ReadDir",event_funs) == -1)
        EVENTS_D->AddEvent("/secure/daemon/file","/secure/daemon/file","ReadDir",({ }),90000,1);
    if(member_array("ReadFuns",event_funs) == -1)
        EVENTS_D->AddEvent("/secure/daemon/function","/secure/daemon/function","ReadFuns",({ }),100000,1);
    if(member_array("RotateLogs",event_funs) == -1)
        EVENTS_D->AddEvent("/secure/daemon/log","/secure/daemon/log","RotateLogs",({ }),3600,1);

    newfile = read_file("/secure/cfg/read.cfg");
    if(!grepp(newfile,"/domains/cave/")){
        newfile += "(/domains/cave/) ASSIST:CMDS:CAVE\n";
    }
    write_file("/secure/cfg/read.cfg",newfile,1);


    catch( reload("/secure/daemon/master",0,1) );
    catch( reload("/secure/sefun/arrays",0,1) );
    catch( reload("/secure/sefun/sefun",0,1) );

    catch( reload("/domains/default/room/stargate_lab.c",0,1));
    catch( reload("/domains/town/virtual/space/1,1,1",0,1));
    catch( reload("/domains/town/virtual/bottom/33,100000",0,1));
    catch( reload("/domains/Praxis/square.c",0,1));
    catch( reload("/domains/Ylsrim/room/tower",0,1));
    catch( reload("/domains/campus/room/slab",0,1));
    update(RELOAD_D,0,1);

    if(whom){
        tell_player(whom,"Update daemon finished.");
        if(query_os_type() == "windows" || uptime() < 240){
            tell_player(whom,"Rebooting now is a good idea.");
        }
        else tell_player(whom,"Initiating warm boot.");
    }

    if(query_os_type() != "windows"){
        RELOAD_D->WarmBoot();
    }
    if(connect_warn){
        CHAT_D->eventSendChannel("UPDATE_D", "admin", shiz);
    }
}

static void create() {
    object whom;
    daemon::create();
    catch( load_object("/secure/cmds/admins/removeraces")->cmd());
    catch( load_object("/secure/cmds/admins/addraces")->cmd());
    if(this_player()) whom = this_player();
    call_out((: eventUpdate :), 1, whom);
    if(whom){
        tell_player(whom,"Please stand by until you see the \"Update daemon finished.\" message.");
        tell_player(whom,"If you do not see it after a few seconds, you may need to restore "
          "your mud from backup.");
    }
}
